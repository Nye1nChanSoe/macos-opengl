# Event-Driven Architecture

## Event Creation

Events represent something that has happened, such as:

- `KeyPressedEvent`
- `MouseMovedEvent`
- `WindowResizedEvent`

Events are implemented as **objects or classes** containing data related to that specific event.

### Workflow

1. **Each Event Type**:

   - Derived from a base `Event` class.
   - Subclasses implement the `Event` interface.

2. **When an Event Occurs**:

   - The `Window` class detects the event (e.g., via GLFW callbacks).
   - A specific event object (e.g., `WindowClosedEvent`) is created.

3. **Passing to Dispatcher**:
   - The event object is passed to the `EventDispatcher` for processing.

---

## Event Dispatching (Dispatcher)

The `EventDispatcher` is responsible for delivering events to all interested parties (subscribers).

### 1. Dispatching

- The dispatcher receives an event instance and determines its type (e.g., `KeyPressedEvent`).
- It finds all registered callbacks for that event type.

### 2. Handling

- The dispatcher invokes each registered callback, passing the event instance.
- Callbacks process the event and can mark it as "handled" to stop further propagation.

---

## Subscribing to Events

Subscribing means registering a function or method to be called whenever a specific type of event occurs.

### Workflow

1. **Register a Callback**:

   - A class registers interest in a specific event type by providing a callback to the dispatcher.
   - The callback can be a free function, lambda, or member method (via `std::bind`).

2. **Listening**:
   - When the event occurs, the dispatcher invokes the registered callback for that event type.

---

## Terminologies

1. **Subscriber**: The entity (class or object) that registers a callback method to the dispatcher.
2. **Callback**: The function or method executed when an event occurs.
3. **Dispatcher**: Routes events to registered callbacks.
4. **Actual Events**: Events generated by an external system or framework (e.g., GLFW).

---

## Flow of Events in This System

### 1. Event Occurrence

- The `Window` class detects an event via GLFW callbacks (e.g., `glfwSetWindowCloseCallback`).

### 2. Event Creation

- Inside the GLFW callback, a user-defined event object (e.g., `WindowClosedEvent`) is created.

### 3. Dispatching Logic

- The GLFW callback invokes `props.eventCallback(event)`.
- `props.eventCallback` is bound to `Application::OnEvent` in the `Application` constructor:
  ```cpp
  m_Window->SetEventCallback(BIND(OnEvent));
  ```

### 4. Dispatcher Handles the Event

- Inside `Application::OnEvent`, an `EventDispatcher` is created:
  ```cpp
  EventDispatcher dispatcher(e);
  ```
- The dispatcher routes the event to callbacks registered for its type:
  ```cpp
  dispatcher.Dispatch<WindowClosedEvent>(BIND(OnWindowClose));
  ```

### 5. Registering Callbacks

- Callbacks for specific events are registered in classes (e.g., `Application`, `Layers`) using `std::bind`:
  ```cpp
  dispatcher.Dispatch<WindowClosedEvent>(BIND(OnWindowClose));
  ```
